/*-------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * tests/common/mod.rs
 *
 *-------------------------------------------------------------------------
 */

pub mod rbac_utils;
pub mod validation_utils;

use std::{
    backtrace::Backtrace,
    sync::{Arc, Once},
    thread,
    time::Duration,
};

use documentdb_gateway::{
    configuration::{
        CertInputType, CertificateOptions, DocumentDBSetupConfiguration, PgConfiguration,
        SetupConfiguration,
    },
    error::Result,
    postgres::{
        create_query_catalog, ConnectionPool, DocumentDBDataClient, QueryCatalog,
        AUTHENTICATION_MAX_CONNECTIONS, SYSTEM_REQUESTS_MAX_CONNECTIONS,
    },
    run_gateway,
    service::TlsProvider,
    startup::get_service_context,
};
use mongodb::{
    options::{AuthMechanism, ClientOptions, Credential, ServerAddress, Tls, TlsOptions},
    Client, Database,
};
use tokio_postgres::{error::SqlState, NoTls};
use tokio_util::sync::CancellationToken;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};

static INIT: Once = Once::new();

// Starts the server and returns an authenticated client
async fn initialize_full(config: DocumentDBSetupConfiguration) {
    INIT.call_once(|| {
        tracing_subscriber::registry()
            .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info")))
            .with(tracing_subscriber::fmt::layer())
            .init();
        thread::spawn(move || run(config));
        thread::sleep(Duration::from_millis(100));
    });

    create_user("test", "test", &create_query_catalog())
        .await
        .unwrap();
}

#[tokio::main]
async fn run(setup_config: DocumentDBSetupConfiguration) {
    let tls_provider = TlsProvider::new(
        SetupConfiguration::certificate_options(&setup_config),
        None,
        None,
    )
    .await
    .expect("Failed to create TLS provider.");

    let query_catalog = create_query_catalog();
    let postgres_system_user = setup_config.postgres_system_user();
    let system_pool = Arc::new(
        ConnectionPool::new_with_user(
            &setup_config,
            &query_catalog,
            &postgres_system_user,
            None,
            format!("{}-SystemRequests", setup_config.application_name()),
            SYSTEM_REQUESTS_MAX_CONNECTIONS,
        )
        .expect("Failed to create system pool"),
    );

    let dynamic_configuration = PgConfiguration::new(
        &query_catalog,
        &setup_config,
        &system_pool,
        vec!["documentdb.".to_string()],
    )
    .await
    .unwrap();

    let authentication_pool = ConnectionPool::new_with_user(
        &setup_config,
        &query_catalog,
        &postgres_system_user,
        None,
        format!("{}-PreAuthRequests", setup_config.application_name()),
        AUTHENTICATION_MAX_CONNECTIONS,
    )
    .expect("Failed to create authentication pool");

    let service_context = get_service_context(
        Box::new(setup_config),
        dynamic_configuration,
        query_catalog,
        system_pool,
        authentication_pool,
        tls_provider,
    );

    run_gateway::<DocumentDBDataClient>(service_context, None, CancellationToken::new())
        .await
        .unwrap();
}

pub fn setup_configuration() -> DocumentDBSetupConfiguration {
    DocumentDBSetupConfiguration {
        node_host_name: "localhost".to_string(),
        blocked_role_prefixes: Vec::new(),
        gateway_listen_port: Some(10260),
        allow_transaction_snapshot: Some(false),
        certificate_options: CertificateOptions {
            cert_type: CertInputType::PemAutoGenerated,
            ..Default::default()
        },
        postgres_system_user: Some(
            std::env::var("PostgresSystemUser").unwrap_or(whoami::username()),
        ),
        is_mongo_sharded: true,
        ..Default::default()
    }
}

pub fn setup_configuration_with_unix_socket_custom(
    path: Option<String>,
    permissions: Option<String>,
) -> DocumentDBSetupConfiguration {
    let mut config = setup_configuration();
    config.unix_socket_path = path;
    config.unix_socket_file_permissions = permissions;
    config
}

pub fn get_client() -> Client {
    let credential = Credential::builder()
        .username("test".to_string())
        .password("test".to_string())
        .mechanism(AuthMechanism::ScramSha256)
        .build();

    let client_options = ClientOptions::builder()
        .credential(credential)
        .tls(Tls::Enabled(
            TlsOptions::builder()
                .allow_invalid_certificates(true)
                .build(),
        ))
        .hosts(vec![ServerAddress::parse("127.0.0.1:10260").unwrap()])
        .build();
    Client::with_options(client_options).unwrap()
}

#[allow(dead_code)]
pub fn get_client_insecure() -> Client {
    let credential = Credential::builder()
        .username("test".to_string())
        .password("test".to_string())
        .mechanism(AuthMechanism::ScramSha256)
        .build();

    let client_options = ClientOptions::builder()
        .credential(credential)
        .hosts(vec![ServerAddress::parse("127.0.0.1:10260").unwrap()])
        .build();
    Client::with_options(client_options).unwrap()
}

#[allow(dead_code)]
pub async fn initialize_with_logger() -> Client {
    initialize_full(setup_configuration()).await;
    get_client()
}

#[allow(dead_code)]
pub async fn initialize_with_config(config: DocumentDBSetupConfiguration) -> Client {
    initialize_full(config).await;
    get_client()
}

#[allow(dead_code)]
pub fn get_unix_socket_client_custom(path: &str) -> Client {
    use std::time::Duration;
    let credential = Credential::builder()
        .username("test".to_string())
        .password("test".to_string())
        .mechanism(AuthMechanism::ScramSha256)
        .build();

    let client_options = ClientOptions::builder()
        .credential(credential)
        .hosts(vec![ServerAddress::parse(path).unwrap()])
        .connect_timeout(Duration::from_millis(100))
        .server_selection_timeout(Duration::from_millis(100))
        .build();
    Client::with_options(client_options).unwrap()
}

#[allow(dead_code)]
pub async fn initialize_with_config_and_unix(path: Option<String>) -> (Client, Option<Client>) {
    let config = setup_configuration_with_unix_socket_custom(path.clone(), None);
    initialize_full(config).await;

    let tcp_client = get_client();
    let unix_client = path.map(|socket_path| get_unix_socket_client_custom(&socket_path));

    (tcp_client, unix_client)
}

#[allow(dead_code)]
pub async fn initialize() -> Client {
    initialize_full(setup_configuration()).await;
    get_client()
}

pub async fn create_user(user: &str, pass: &str, query_catalog: &QueryCatalog) -> Result<()> {
    let (client, connection) = tokio_postgres::Config::new()
        .host("localhost")
        .port(9712)
        .dbname("postgres")
        .connect(NoTls)
        .await
        .unwrap();
    tokio::spawn(connection);

    let statement = query_catalog.create_db_user(user, pass);
    match client.batch_execute(&statement).await {
        Err(e) => {
            if e.code()
                .is_some_and(|code| code == &SqlState::DUPLICATE_OBJECT)
            {
                Ok(())
            } else {
                Err(documentdb_gateway::error::DocumentDBError::PostgresError(
                    e,
                    Backtrace::capture(),
                ))
            }
        }
        Ok(_) => Ok(()),
    }?;

    client
        .batch_execute(&format!("ALTER ROLE {user} SUPERUSER"))
        .await
        .unwrap();

    if let tokio_postgres::SimpleQueryMessage::Row(result) = client
        .simple_query(&format!("SELECT * FROM pg_roles WHERE rolname = '{user}'"))
        .await
        .unwrap()
        .first()
        .unwrap()
    {
        tracing::info!("Test can create: {:?}", result.get("rolcreaterole"));
    }
    Ok(())
}

// Initialize the server and also clear a database for use
#[allow(dead_code)]
pub async fn initialize_with_db(db: &str) -> Database {
    let client = initialize().await;
    setup_db(&client, db).await
}

#[allow(dead_code)]
pub async fn setup_db(client: &Client, db: &str) -> Database {
    let db = client.database(db);

    // Make sure the DB is clean
    db.drop().await.unwrap();
    db
}
